<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象 | lei哥的技术博客</title>
    <meta name="description" content="当你处于一个上升状态时，你会体会到工作带给你的成就感和物质回报，你不会想回头多看一眼那些努力挣扎却又收效甚微的过往，你只会感叹为什么没有早点开始。">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.afd5c948.css" as="style"><link rel="preload" href="/blog/assets/js/app.0b545b11.js" as="script"><link rel="preload" href="/blog/assets/js/2.f10681ce.js" as="script"><link rel="preload" href="/blog/assets/js/20.a78c75bc.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ce1fffca.js"><link rel="prefetch" href="/blog/assets/js/11.94b8e5f1.js"><link rel="prefetch" href="/blog/assets/js/12.191371e4.js"><link rel="prefetch" href="/blog/assets/js/13.875ebad6.js"><link rel="prefetch" href="/blog/assets/js/14.5a62e216.js"><link rel="prefetch" href="/blog/assets/js/15.df488d4e.js"><link rel="prefetch" href="/blog/assets/js/16.93503c2c.js"><link rel="prefetch" href="/blog/assets/js/17.88d75b76.js"><link rel="prefetch" href="/blog/assets/js/18.5ef3844f.js"><link rel="prefetch" href="/blog/assets/js/19.bd597017.js"><link rel="prefetch" href="/blog/assets/js/21.f4322287.js"><link rel="prefetch" href="/blog/assets/js/22.e59558e8.js"><link rel="prefetch" href="/blog/assets/js/23.4ae26fa4.js"><link rel="prefetch" href="/blog/assets/js/24.284e0a8b.js"><link rel="prefetch" href="/blog/assets/js/25.d7bf2f1a.js"><link rel="prefetch" href="/blog/assets/js/26.9c175940.js"><link rel="prefetch" href="/blog/assets/js/27.51d0aaaa.js"><link rel="prefetch" href="/blog/assets/js/28.ac6e2447.js"><link rel="prefetch" href="/blog/assets/js/29.366f7488.js"><link rel="prefetch" href="/blog/assets/js/3.6a4470bd.js"><link rel="prefetch" href="/blog/assets/js/30.bbc6ca5a.js"><link rel="prefetch" href="/blog/assets/js/31.006fcaad.js"><link rel="prefetch" href="/blog/assets/js/32.07d28013.js"><link rel="prefetch" href="/blog/assets/js/33.890b73e7.js"><link rel="prefetch" href="/blog/assets/js/34.f2fcb330.js"><link rel="prefetch" href="/blog/assets/js/35.99113197.js"><link rel="prefetch" href="/blog/assets/js/36.beee7fb7.js"><link rel="prefetch" href="/blog/assets/js/37.5964e829.js"><link rel="prefetch" href="/blog/assets/js/38.9214b223.js"><link rel="prefetch" href="/blog/assets/js/39.9d4bfb2f.js"><link rel="prefetch" href="/blog/assets/js/4.72bd1ba7.js"><link rel="prefetch" href="/blog/assets/js/40.e0a18503.js"><link rel="prefetch" href="/blog/assets/js/41.5188182c.js"><link rel="prefetch" href="/blog/assets/js/42.3d1a36e2.js"><link rel="prefetch" href="/blog/assets/js/43.a3ed974a.js"><link rel="prefetch" href="/blog/assets/js/44.e55e7cab.js"><link rel="prefetch" href="/blog/assets/js/5.e83018fc.js"><link rel="prefetch" href="/blog/assets/js/6.82ceca1a.js"><link rel="prefetch" href="/blog/assets/js/7.cf266e18.js"><link rel="prefetch" href="/blog/assets/js/8.fd6773be.js"><link rel="prefetch" href="/blog/assets/js/9.4ea8f280.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.afd5c948.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">lei哥的技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">
  环境配置
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/md.html" class="nav-link">
  markdown语法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="重点技术" class="dropdown-title"><span class="title">重点技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/skulpt/1.html" class="nav-link">
  深入skulpt
</a></li><li class="dropdown-item"><!----> <a href="/blog/scratch/links.html" class="nav-link">
  深入scratch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术积累" class="dropdown-title"><span class="title">技术积累</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/img.html" class="nav-link">
  图片相关总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-bug.html" class="nav-link">
  遇到的坑
</a></li><li class="dropdown-item"><!----> <a href="/blog/css/base-css.html" class="nav-link">
  css3
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS开发总结" class="dropdown-title"><span class="title">JS开发总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/inherit.html" class="nav-link">
  js继承
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-base.html" class="nav-link">
  js基础总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/inherit2.html" class="nav-link">
  js继承(二)
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/obj.html" class="nav-link router-link-exact-active router-link-active">
  面向对象
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/yinyong.html" class="nav-link">
  引用对象
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-tip.html" class="nav-link">
  js各种知识点
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/yibu.html" class="nav-link">
  异步汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/core.html" class="nav-link">
  跨域相关
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/es6.html" class="nav-link">
  ES6知识
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/tool-fun.html" class="nav-link">
  工具函数总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/write-code.html" class="nav-link">
  手写代码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="移动端" class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/mobile/wechat.html" class="nav-link">
  公众号开发总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/optimize.html" class="nav-link">
  移动端性能优化(一)
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/optimize2.html" class="nav-link">
  移动端性能优化(二)
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/mobile-bug.html" class="nav-link">
  移动端的那些坑
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/vue/knowledgePoint.html" class="nav-link">
  Vue小知识
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni-app.html" class="nav-link">
  Uniapp学习
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-base.html" class="nav-link">
  webpack入门
</a></li><li class="dropdown-item"><!----> <a href="/blog/webpack/perform-opt.html" class="nav-link">
  webpack优化
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-note.html" class="nav-link">
  webpack随手记
</a></li></ul></div></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">
  常用网址
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程" class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">
  环境配置
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/md.html" class="nav-link">
  markdown语法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="重点技术" class="dropdown-title"><span class="title">重点技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/skulpt/1.html" class="nav-link">
  深入skulpt
</a></li><li class="dropdown-item"><!----> <a href="/blog/scratch/links.html" class="nav-link">
  深入scratch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术积累" class="dropdown-title"><span class="title">技术积累</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/img.html" class="nav-link">
  图片相关总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-bug.html" class="nav-link">
  遇到的坑
</a></li><li class="dropdown-item"><!----> <a href="/blog/css/base-css.html" class="nav-link">
  css3
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS开发总结" class="dropdown-title"><span class="title">JS开发总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/inherit.html" class="nav-link">
  js继承
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-base.html" class="nav-link">
  js基础总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/inherit2.html" class="nav-link">
  js继承(二)
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/obj.html" class="nav-link router-link-exact-active router-link-active">
  面向对象
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/yinyong.html" class="nav-link">
  引用对象
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/js-tip.html" class="nav-link">
  js各种知识点
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/yibu.html" class="nav-link">
  异步汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/core.html" class="nav-link">
  跨域相关
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/es6.html" class="nav-link">
  ES6知识
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/tool-fun.html" class="nav-link">
  工具函数总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/write-code.html" class="nav-link">
  手写代码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="移动端" class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/mobile/wechat.html" class="nav-link">
  公众号开发总结
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/optimize.html" class="nav-link">
  移动端性能优化(一)
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/optimize2.html" class="nav-link">
  移动端性能优化(二)
</a></li><li class="dropdown-item"><!----> <a href="/blog/mobile/mobile-bug.html" class="nav-link">
  移动端的那些坑
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/vue/knowledgePoint.html" class="nav-link">
  Vue小知识
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni-app.html" class="nav-link">
  Uniapp学习
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-base.html" class="nav-link">
  webpack入门
</a></li><li class="dropdown-item"><!----> <a href="/blog/webpack/perform-opt.html" class="nav-link">
  webpack优化
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-note.html" class="nav-link">
  webpack随手记
</a></li></ul></div></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">
  常用网址
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面向对象</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/javascript/obj.html#什么是对象" class="sidebar-link">什么是对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/javascript/obj.html#面向对象的特点" class="sidebar-link">面向对象的特点</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <h2 id="什么是对象"><a href="#什么是对象" class="header-anchor">#</a> 什么是对象</h2> <p>&quot;无序属性的集合，其属性可以包括基本值、对象或者函数&quot;，对象是一组没有特定顺序的的值。对象的没个属性或方法都有一个名字，每个名字都映射到一个值。<br>
简单来理解对象就是由属性和方法来组成的。<br></p> <h3 id="面向对象的特点"><a href="#面向对象的特点" class="header-anchor">#</a> 面向对象的特点</h3> <p>封装<br>
对于一些功能相同或者相似的代码，我们可以放到一个函数中去，多次用到此功能时，我们只需要调用即可，无需多次重写。<br>
创造对象的几种模式：单例模式、工厂模式、构造函数模式、原型模式等。<br>
继承<br>
子类可以继承父类的属性和方法。<br>
多态(重载和重写)<br>
    重载：严格意义上说js中没有重载的功能，不过我们可以通过判断函数的参数的不同来实现不同的功能来模拟重载。<br>
    重写：子类可以改写父类的属性和方法。<br></p> <h4 id="javascript中的封装"><a href="#javascript中的封装" class="header-anchor">#</a> javascript中的封装</h4> <p><b>单例模式</b>
小王在一个小公司，就自己一个前端，所以他写js都是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>后来公司又招了个前端小明，于是变成他们2个一起写同一个js了。一天小王发现自己写的getNum方法出问题了，原来是小华写的js中也有个getNum的函数，代码合并后把他的覆盖掉了，于是便找小华理论去，经过一番妥协后，两人都把自己的代码改了改。<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> xiaoming <span class="token operator">=</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">getNum</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> xiaohua <span class="token operator">=</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token function-variable function">getNum</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这就是我们所谓的单例模式(命名空间)
我们把描述同一个事物的方法或者属性放到同一个对象里，不同事物之间的方法或者属性名相同相互也不会发生冲突。<br></p> <p><b>单例模式的优劣</b><br>
使用单例模式，我们可以实现简单的模块化开发<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">getCss</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//code</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">getByClass</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment">//code</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">setCss</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以把自己写好的工具方法放到一个单独的js文件中，然后直接引入即可。<br></p> <p>避免了全局变量名的冲突<br>
需要注意的是，我们在引入各个模块的时候，需要注意引入的顺序，引入顺序是按照各模块之间的相互依赖进行前后排列的；<br>
缺点：<br>
单例模式只是一定程度上避免了变量名的冲突，但并不能彻底解决此问题，而且在不同的对象下，我们可能会有很多功能相同的代码，最终造成大量的冗余代码。<br>
单例模式让每个对象有了自己独立的命名空间，但是并不能批量生产的问题，每一个新的对象都要重新写一份一模一样的代码。<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token string">'小明'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span><span class="token number">24</span><span class="token punctuation">,</span>
    <span class="token function-variable function">showName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的名字是：'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token string">'小华'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span><span class="token number">25</span><span class="token punctuation">,</span>
    <span class="token function-variable function">showName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的名字是：'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><b>工厂模式</b></p> <p>工厂模式其实就是把需要一个个的编写的对象,放在一个函数中统一的进行创建，说白了就是普通函数的封装。<br>
工厂模式是编程领域一种广为人知的设计模式，它抽象了创建具体对象的过程。JS 中创建一个函数，把创建新对象、添加对象属性、返回对象的过程放到这个函数中，用户只需调用函数来生成对象而无需关注对象创建细节，这叫工厂模式。<br>
工厂模式总共3步骤：<br>
1）进厂 --- 创建一个空对象<br>
2）加工 --- 加工对象：给对象添加属性和方法；<br>
3）输出 --- 返回对象：return 对象；<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CreatePerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//1.创建一个空对象</span>
    <span class="token comment">//2.加工对象</span>
    obj<span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function-variable function">showName</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的名字是：'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token comment">//3.输出对象；</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小华'</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我的名字是：小明</span>
person2<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我的名字是：小华</span>
</code></pre></div><p>工厂模式的优缺点<br>
既然叫工厂模式，它就和我们周围的工厂一样，我们只需要把原材料放进去，就能得到我们需要的产品了。<br>
工厂模式也解决了单例模式的批量生产的问题，避免了单例模式中的大量冗余代码，进行系统的封装，提高代码的重复利用率<br>
不过工厂模式跟我们js内置类的调用方法不同，因为是调用函创建对象，无法识别对象的类型<br></p> <p><b>构造函数模式</b><br>
可以创建一个自定义的类，并且可以new出实例<br>
构造函数做的就是类和实例打交道。<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//构造函数：首字母大写(约定俗成)；</span>
<span class="token keyword">function</span> <span class="token function">CreatePerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//创建一个自定义的类</span>
    <span class="token comment">//构造函数中的this，都是new出来的实例</span>
    <span class="token comment">//构造函数中存放的都是私有的属性和方法；</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">showName</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的名字是：'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//实例1</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token comment">//实例2</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小华'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span>
</code></pre></div><p>这里说一下工厂模式和构造函数模式的区别：<br></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ol><li>在调用的时候不同：
工厂模式：调用的时候，只是普通函数的调用createPerson();
构造函数模式：new CreatePerson();</li> <li>在函数体内不同：
工厂模式有三步：1）创建对象 2）加工对象 3）返回对象；
构造函数模式只有1步： 只有加工对象； 因为系统默认会为其创建对象和返回对象；</li> <li>构造函数默认给我们返回了一个对象，如果我们非要自己手动返回的话：
(1)手动返回的是字符串类型：对以前实例上的属性和方法没有影响；
(2)手动返回的是引用数据类型:以前实例身上的属性和方法就被覆盖了；实例无法调用属性和方法；</li></ol></div> <p>构造函数的方法都是私有方法，每个实例调用的都是自己私有的方法，即构造函数方法要在每个实例上新建一次，同样也会有许多重复的代码。<br>
我们可以使用原型模式来解决每个实例中都有相同方法的函数的问题<br>
解决了类似对象创建问题，且可以检测对象类型。<br></p> <p><b>原型模式</b><br>
终于讲到了原型模式，JS 中每个构造函数都有一个prototype属性，这个属性是一个指针，指向原型对象，而这个原型对象包含了这个构造函数所有实例共享的属性和方法。而实例对象中有一个proto属性，它指向原型对象，也就是构造函数.prototype == 原型对象 == 对象.<em>proto</em>，那么对象就可以获取到原型对象中的属性和方法啦。同时，所有对象中都有一个constructor属性，原型对象的constructor指向其对应的构造函数。<br></p> <p>使用原型，就意味着我们可以把希望实例共享的属性和方法放到原型对象中去，而不是放在构造函数中，这样每一次通过构造函数new一个实例，原型对象中定义的方法都不会重新创建一次。来看下面的例子：<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;leon&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">&quot;20&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">greeting</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hi!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;leon&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;leon&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>greeting <span class="token operator">==</span> person2<span class="token punctuation">.</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

</code></pre></div><p>优点：与单纯使用构造函数不一样，原型对象中的方法不会在实例中重新创建一次，节约内存。<br>
缺点：使用空构造函数，实例 person1 和 person2 的 name都一样了，我们显然不希望所有实例属性方法都一样，它们还是要有自己独有的属性方法。并且如果原型中对象中有引用类型值，实例中获得的都是该值的引用，意味着一个实例修改了这个值，其他实例中的值都会相应改变。<br>
解决办法：构造函数+原型模式组合使用。<br>
另外 JS 中还定义了一些与原型相关的属性，这里罗列一下：<br>
Object.getPrototypeOf()，取得实例的原型对象。</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>isPrototypeOf()，判断是不是一个实例的原型对象。<br></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>hasOwnProperty()，检测一个属性是否存在于实例中<br></p> <div class="language-js extra-class"><pre class="language-js"><code>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>in，判断一个属性是否存在于实例和原型中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> person1<span class="token punctuation">;</span>
</code></pre></div><p><b>构造函数+原型模式</b></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CreatePerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 我们把公有的方法放到函数的原型链上</span>
<span class="token class-name">CreatePerson</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的名字是：'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>  
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span> 
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreatePerson</span><span class="token punctuation">(</span><span class="token string">'小华'</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span>
person1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//小明</span>
</code></pre></div><p>原型模式的关键：<br>
1）每个函数数据类型（普通函数，类）上，都有一个属性，叫prototype。<br>
2）prototype这个对象上，天生自带一个属性，叫constructor:指向当前这个类；<br>
3）每个对象数据类型（普通对象，prototype，实例）上都有一个属性，叫做__proto__:指向当前实例所属类的原型；<br></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.0b545b11.js" defer></script><script src="/blog/assets/js/2.f10681ce.js" defer></script><script src="/blog/assets/js/20.a78c75bc.js" defer></script>
  </body>
</html>
