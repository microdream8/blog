(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{290:function(t,s,a){"use strict";a.r(s);var r=a(28),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"源起"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源起"}},[t._v("#")]),t._v(" 源起")]),t._v(" "),a("p",[t._v("JavaScript 已经占领了世界上的每一个角落，能访问网页的地方，基本上就有 JavaScript 在运作，然而 JavaScript "),a("strong",[t._v("因为其动态、弱类型、解释型语言的特性、出错的调用栈隐蔽，使得开发者不仅在调试错误上花费大把时间，在团队协作开发时理解队友编写代码也极其困难")]),t._v("。TypeScript 的出现极大的解决了上面的问题，TypeScript -- 一个 JavaScript 的超集，它作为一门编译型语言，提供了对类型系统和最新 ES 语法的支持，使得我们可以在享受使用 ES 最新语法的编写代码的同时，还能在写代码的过程中就规避很多潜在的语法、语义错误；并且其提供的类型系统使得我们可以在团队协作编写代码时可以很容易的了解队友代码的含义：输入和输出，大大提高了团队协作编写大型业务应用的效率。在现代 JavaScript 世界中，已经有很多大型库在使用 TypeScript 重构，包括前端三大框架：React、Vue、Angular，还有知名的组件库 antd，material，在很多公司内部的大型业务应用也在用 TypeScript 开发甚至重写现有的应用，所以如果你想编写大型业务应用或库，或者想写出更利于团队协作的代码，那么 TypeScript 有十足的理由值得你学习！")]),t._v(" "),a("h1",{attrs:{id:"typescript初探"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript初探"}},[t._v("#")]),t._v(" TypeScript初探")]),t._v(" "),a("p",[t._v("TypeScript 是 JavaScript 的超集, 支持 JavaScript 的写法，并且提供类型检查，TypeScript 提供了一些面向对象编程的能力。\nTS 是一门静态编程语言，它是 JavaScript 的超集，主要包含着两类属性：")]),t._v(" "),a("ul",[a("li",[t._v("属于 JavaScript 端的编程语言特性，使得我们可以执行各种 JavaScript 相关的操作：变量声明、编写 if/else 控制流、使用循环处理重复任务、使用函数执行特定的任务块、使用类来组织和复用代码和模拟真实世界的操作等，还有新特性比如：装饰器、Iterator、Generator 这些。这类特性在此篇文章中，我们默认你已经很清楚了，不会做过多的讲解。")]),t._v(" "),a("li",[t._v("属于 TypeScript 端独有的特性：类型，它也具有一套编程语言的特性，比如标志一个变量是 string 类型，一个函数的参数有三个，它们的类型分别是 string/number/boolean，返回类型为 never等，这是基础类型，我们甚至可以基于类型进行编程，使用类型版本的控制、组织结构来完成高级类型的编写，进而将类型附着在 JavaScript 对应的编程语言特性上，将 JS 静态化，使得我们可以在编译期间就能发现类型上的错误，这一特性是我们本篇文章的重点。")])]),t._v(" "),a("p",[t._v("好的，读到这里，相比很多读者已经清楚了，其实 TS 没什么神秘的，主要就是设计了一套类似编程语言的类型语言，然后将这些类型附着在原 JavaScript 的语言之上，给其加上类型限制使得其静态化，进而可以快速的在编写时发现很多潜在的问题，帮助我们编写错误率更低，更适合团队协作的代码，这也是 TypeScript 适合编写大型的业务应用的原因。")]),t._v(" "),a("h2",{attrs:{id:"类型语言之数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型语言之数据结构"}},[t._v("#")]),t._v(" 类型语言之数据结构")]),t._v(" "),a("p",[t._v("其中 TS 数据结构又包含原始类型、非原始类型、特殊类型和高级类型等几类。我们将结合在 TS 类型侧的定义，以及附着在 JS 上进行实战来讲解。")]),t._v(" "),a("h3",{attrs:{id:"原始类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原始类型"}},[t._v("#")]),t._v(" 原始类型")]),t._v(" "),a("h4",{attrs:{id:"ts类型侧的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ts类型侧的定义"}},[t._v("#")]),t._v(" TS类型侧的定义")]),t._v(" "),a("p",[t._v("和 JS 中的原始数据类型一样，TS 对应着一致的类型定义，包括下面八种：")]),t._v(" "),a("ul",[a("li",[t._v("number")]),t._v(" "),a("li",[t._v("string")]),t._v(" "),a("li",[t._v("boolean")]),t._v(" "),a("li",[t._v("null")]),t._v(" "),a("li",[t._v("undefined")]),t._v(" "),a("li",[t._v("void")]),t._v(" "),a("li",[t._v("symbol")]),t._v(" "),a("li",[t._v("bigint")])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("其中前六种是 ES5 中就有的，symbol 从 ES6 开始引入，bigint 是 ES2020 新引进的。")])]),t._v(" "),a("p",[a("strong",[t._v("never")]),t._v("表示永远不存在值的类型，没有值可以赋值给 Never 类型")]),t._v(" "),a("p",[a("strong",[t._v("any")]),t._v("表示可以成为任何类型，比如设定一个变量 没想好它是什么类型的，但是又要通过类型检查，可以设定为 Any")]),t._v(" "),a("p",[a("strong",[t._v("void")]),t._v("表示没有任何类型,比如一些函数没有返回值，可以把这个函数设置为 void 型")]),t._v(" "),a("p",[t._v("上面是 TS 的原始类型，我们之前提到 TS 就是将类型附着在 JS 上，将其类型化，那么我们来看看上面的原始类型如何附着在 JS 上，将其类型化。")]),t._v(" "),a("h4",{attrs:{id:"附着在js的实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附着在js的实战"}},[t._v("#")]),t._v(" 附着在JS的实战")]),t._v(" "),a("p",[t._v("TS 通过独特的冒号语法来将其类型侧定义的类型附着在 JS 上，我们来看几个例子：")]),t._v(" "),a("ul",[a("li",[t._v("字符串")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello,Wrold!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("我们可以确定，这是一个 string 类型的，所以我们用对应的 TS 类型附着在其变量定义上如下：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" str"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello,Wrold!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这样我们就给原 JS 的 str  变量加上了类型定义，它是一个 string  类型的变量，通过这样的操作，原 JS 变量的类型就被静态化了，在初始化时，就不能再赋值其他的类型给这个 str 变量了，比如我们将 number 类型的字面量赋值给 str ，就会报错：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" str"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5201314")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 报错 Type '5201314' is not assignable to Type 'string'")]),t._v("\n")])])]),a("ul",[a("li",[t._v("空值\n表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void：")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("warnUser")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is my warning message"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("实际上只有null和undefined可以赋给void:")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n")])])]),a("ul",[a("li",[t._v("Null 和 Undefined\nTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null，和void相似，它们的本身的类型用处不是很大：")])]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("默认情况下 null 和 undefined 是所有类型的子类型，就是说你可以把 null 和 undefined 赋值给 number 类型的变量。")]),t._v(" "),a("p",[t._v("但是在正式项目中一般都是开启 --strictNullChecks 检测的，即 null 和 undefined 只能赋值给 any 和它们各自(一个例外是 undefined 是也可以分配给void)，可以规避非常多的问题。")]),t._v(" "),a("ul",[a("li",[t._v("any\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。")])]),t._v(" "),a("p",[t._v("这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。")]),t._v(" "),a("p",[t._v("这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" notSure"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnotSure "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"maybe a string instead"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("any类型是多人协作项目的大忌，很可能把Typescript变成AnyScript，通常在不得已的情况下，不应该首先考虑使用此类型。")]),t._v(" "),a("h4",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("我们上面说到了 TS 的原始类型，一共有八个之多，并且通过其中的 string 类型来讲解了如何将 TS 类型附着在原 JS 语法上以静态化 JS 语言，剩下的 7 个原始类型的用法和 string 类型类似，我们将在之后的讲解中逐渐用到其中的类型。")]),t._v(" "),a("h3",{attrs:{id:"非原始类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非原始类型"}},[t._v("#")]),t._v(" 非原始类型")]),t._v(" "),a("h4",{attrs:{id:"ts类型侧的定义-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ts类型侧的定义-2"}},[t._v("#")]),t._v(" TS类型侧的定义")]),t._v(" "),a("p",[t._v("同样的 JS 中的非原始数据类型一样，TS 中也存在非原始类型，表示除了八种原始类型之外的类型，非原始类型也称为是 object 类型。")]),t._v(" "),a("p",[t._v("实际上 TS 中还有几个常见的非原始类型，例举如下：")]),t._v(" "),a("ul",[a("li",[t._v("array")]),t._v(" "),a("li",[t._v("tuple")]),t._v(" "),a("li",[t._v("enum")])]),t._v(" "),a("p",[t._v("且因为它们属于 object 类型，所以 object 类型实际上就代表了非原始类型。在上面的三个类型以及其父类型 object 中，array 和 object 其实我们应该有点熟悉，至于 tuple 和 enum 则是 TS 中新增的类型，JS 中正式提案中目前是没有的。讲完了类型侧定义，我们马上来实践一下上面的 array 和 enum 非原始类型。")]),t._v(" "),a("h4",{attrs:{id:"array-类型附着实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array-类型附着实战"}},[t._v("#")]),t._v(" array 类型附着实战")]),t._v(" "),a("p",[t._v("其中 array 类型我们比较熟悉，但这里有个不同就是之前我们的 JS 因为是动态语言，所以一个数组里面可以有各种不同的数据类型项，比如我们看如下 JS 语句：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("可以看到，从 TS 的角度去看这个数组变量 arr 所包含的类型，存在字符串类型 '1' 和 '3' ，以及数字类型 2 。但 TS 总的数组类型要求数组中的元素都是同一个类型，不允许动态变化，比如我们为上面的数组变量 arr 声明类型应该如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("可以看到，我们给变量 arr 声明了 string[] 类型，即一个 string 类型后面跟着一个数组标志，表示是字符串数组类型，当声明了 string[] 类型之后，我们需要把之前的数组 2 改成字符串 '2' 。")]),t._v(" "),a("p",[t._v("我们注意到 array 类型，它要求数组中每项的类型都一样，一般应用在数组的长度未知的情况，用特定的类型，比如 string 类型来约束数组的每一项。")]),t._v(" "),a("p",[t._v("然而从 JS 转过来的同学大多数同学可能对这个 array 类型不适应了，我们 JS 的同学经常会遇到编写一个数组，其中的多项的类型不一样，就和我们上面的 JS arr 的项一样，既有 string 类型又有 number 类型，那这该怎么办了？还好！TS 的设计者也为我们考虑到了这一点，那就是我们下面要讲到的 tuple  （元组）类型。")]),t._v(" "),a("h4",{attrs:{id:"tuple-类型附着实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tuple-类型附着实战"}},[t._v("#")]),t._v(" tuple 类型附着实战")]),t._v(" "),a("p",[t._v("大家可能对 tuple （元组）类型很陌生了，其实元组是一种特殊的数组类型，它主要用于这样的场景：“一个数组的项数已知，其中每项的类型也已知”，这句话说起来可能比较绕，我们用上面讲数组的例子来讲元组：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("h2",{attrs:{id:"为什么typescript是好的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么typescript是好的"}},[t._v("#")]),t._v(" 为什么TypeScript是好的")]),t._v(" "),a("p",[t._v("如果你现在还没有开始学习 TS，肯定是因为对 TS 有所顾虑。去问问用了 TS 的前端感觉怎么样吧，基本没有一个说后悔的。所以这种顾虑是完全没有必要的。")]),t._v(" "),a("p",[t._v("那么 TS 为什么这么好呢？接下来我们从理论上解释一下。")]),t._v(" "),a("ol",[a("li",[t._v("写代码最怕什么？代码出错，也就是 bug。")]),t._v(" "),a("li",[t._v("如何避免 bug？运行代码看结果，或者添加各种测试。")]),t._v(" "),a("li",[t._v("现在前端并不流行单元测试，所以只能运行代码看结果（比如刷新页面，然后用鼠标点点点，看是否能运行成功）")]),t._v(" "),a("li",[t._v("但当你的前端应用非常大的时候，你不可能每次改代码之后去所有页面上点一遍，因为页面太多了。")]),t._v(" "),a("li",[t._v("所以前端选择模块化，让一次代码改动影响的页面尽量少。但是即使这样，你依然无法通过鼠标点击测试来运行所有代码，因为你可能还需要测试多种不同的账户。")]),t._v(" "),a("li",[t._v("这样做太麻烦了。有没有什么办法能让我快速知道「代码有bug没」")])]),t._v(" "),a("p",[t._v("这是一个重要的问题：有没有什么办法能让我快速知道「代码有bug没」。")]),t._v(" "),a("p",[t._v("为了说明类型是如何解决这个问题的，我们先来介绍一种最简单的类型：正负数。")]),t._v(" "),a("p",[t._v("我们把实数分为三种类型：正数、负数和0。")]),t._v(" "),a("p",[t._v("然后看下面这个等式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("28937829")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1239282")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("35862130598778")]),t._v("\n")])])]),a("p",[t._v("聪明的你一眼就看出这个等式不对。为什么？因为「正数」乘以「负数」必然得到「负数」。所以我们根本不用运行这个乘法，就知道这个结果不对。")]),t._v(" "),a("p",[t._v("这就是类型好处。")]),t._v(" "),a("h2",{attrs:{id:"类型能让你「大概」知道代码对不对"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型能让你「大概」知道代码对不对"}},[t._v("#")]),t._v(" 类型能让你「大概」知道代码对不对")]),t._v(" "),a("p",[t._v("TS 就是在 JS 上加上类型声明，这样我们就能知道代码是否「大概」正确。")]),t._v(" "),a("p",[t._v("另外，这种方式速度非常快，快到你只要修改代码，TS 就能告诉你代码是否「大概」正确。")]),t._v(" "),a("p",[t._v("从而避免很多 bug。")]),t._v(" "),a("p",[t._v("你只需要稍微花一点点时间，就能让代码质量提升，何乐不为呢？")]),t._v(" "),a("h2",{attrs:{id:"听说-ts-只适合大型项目？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#听说-ts-只适合大型项目？"}},[t._v("#")]),t._v(" 听说 TS 只适合大型项目？")]),t._v(" "),a("p",[t._v("错，只要是有 bug 的 JS 项目，都可以用 TS 替代 JS 从而减少 bug。")]),t._v(" "),a("p",[t._v("所以无论是小项目还是大项目，都有必要使用 TS。")]),t._v(" "),a("h2",{attrs:{id:"万一过几年-ts-不火了呢？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#万一过几年-ts-不火了呢？"}},[t._v("#")]),t._v(" 万一过几年 TS 不火了呢？")]),t._v(" "),a("p",[t._v("这个问题问得好，前端发展这么快，很多东西都是火几年就不火了，导致后期想招人维护都难（比如 AngularJS 1）。\n但是 TS 不存在这个问题。为什么？\n因为目前前端三大框架全都支持 TS 了：")]),t._v(" "),a("p",[t._v("Angular 很早就支持 TypeScript 了，而且还把 JS 从自己的名字里去掉了：AngluarJS -> Angular。甚至连 Angular 入门文档里的例子都默认是 TS 版本的。用 JS 写 Angular 不是不可以，只是会显得很「奇怪」，明明有更好的 TS，为什么会有人用 JS。\nVue 3.0 用 TS 重写了，为了更好的支持 TS，甚至放弃了原本计划推出的 class API。\nReact 一开始对 TS 的支持也是非常丝滑。不过 React 并没有强绑定到 TS。")]),t._v(" "),a("p",[t._v("如果有一年 TS 不火了，上面框架的维护者会提前为你想好升级方案的，你就不必过多担心了。\n毕竟背靠大树好乘凉。")]),t._v(" "),a("h2",{attrs:{id:"js-岂不是白学了？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-岂不是白学了？"}},[t._v("#")]),t._v(" JS 岂不是白学了？")]),t._v(" "),a("p",[t._v("No No No，TS 里面包含了 JS 的所有语法，所以你在用 TS 的时候，实际上还是在用 JS。")]),t._v(" "),a("p",[t._v("也就是说 JS 的魂还在，我们只是不再单独使用 JS 了。")]),t._v(" "),a("p",[t._v("参考来源：\nhttps://juejin.im/post/5d19b0305188254e2e4e78e8\nhttps://juejin.im/post/5e8a831cf265da48046988cb")])])}),[],!1,null,null,null);s.default=e.exports}}]);