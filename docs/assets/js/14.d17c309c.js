(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{257:function(e,v,n){"use strict";n.r(v);var _=n(28),l=Object(_.a)({},(function(){var e=this,v=e.$createElement,n=e._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"大厂面试题分类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#大厂面试题分类"}},[e._v("#")]),e._v(" 大厂面试题分类")]),e._v(" "),n("h2",{attrs:{id:"html5和css3相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#html5和css3相关"}},[e._v("#")]),e._v(" html5和css3相关")]),e._v(" "),n("ol",[n("li",[e._v("html语义化的理解")]),e._v(" "),n("li",[e._v("CSS选择器有哪些原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。")])]),e._v(" "),n("p",[e._v("原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。")]),e._v(" "),n("p",[e._v("本节主要介绍前五种原始数据类型在 TypeScript 中的应用。")]),e._v(" "),n("p",[e._v("布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：")]),e._v(" "),n("p",[e._v("let isDone: boolean = false;")]),e._v(" "),n("p",[e._v("// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n注意，使用构造函数 Boolean 创造的对象不是布尔值：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: boolean = new Boolean(1);")]),e._v(" "),n("p",[e._v("// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n事实上 new Boolean() 返回的是一个 Boolean 对象：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: Boolean = new Boolean(1);\n直接调用 Boolean 也可以返回一个 boolean 类型：")]),e._v(" "),n("p",[e._v("let createdByBoolean: boolean = Boolean(1);\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。")]),e._v(" "),n("p",[e._v("数值\n使用 number 定义数值类型：")]),e._v(" "),n("p",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n编译结果：")]),e._v(" "),n("p",[e._v("var decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。")]),e._v(" "),n("p",[e._v("字符串\n使用 string 定义字符串类型：")]),e._v(" "),n("p",[e._v("let myName: string = 'Tom';\nlet myAge: number = 25;")]),e._v(" "),n("p",[e._v("// 模板字符串\nlet sentence: string = "),n("code",[e._v("Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.")]),e._v(";\n编译结果：")]),e._v(" "),n("p",[e._v('var myName = \'Tom\';\nvar myAge = 25;\n// 模板字符串\nvar sentence = "Hello, my name is " + myName + ".\\nI\'ll be " + (myAge + 1) + " years old next month.";\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。')]),e._v(" "),n("p",[e._v("空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：")]),e._v(" "),n("p",[e._v("function alertName(): void {\nalert('My name is Tom');\n}\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：")]),e._v(" "),n("p",[e._v("let unusable: void = undefined;\nNull 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：")]),e._v(" "),n("p",[e._v("let u: undefined = undefined;\nlet n: null = null;\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n而 void 类型的变量不能赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("let u: void;\nlet num: number = u;")]),e._v(" "),n("p",[e._v("// Type 'void' is not assignable to type 'number'.原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。")]),e._v(" "),n("p",[e._v("原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。")]),e._v(" "),n("p",[e._v("本节主要介绍前五种原始数据类型在 TypeScript 中的应用。")]),e._v(" "),n("p",[e._v("布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：")]),e._v(" "),n("p",[e._v("let isDone: boolean = false;")]),e._v(" "),n("p",[e._v("// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n注意，使用构造函数 Boolean 创造的对象不是布尔值：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: boolean = new Boolean(1);")]),e._v(" "),n("p",[e._v("// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n事实上 new Boolean() 返回的是一个 Boolean 对象：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: Boolean = new Boolean(1);\n直接调用 Boolean 也可以返回一个 boolean 类型：")]),e._v(" "),n("p",[e._v("let createdByBoolean: boolean = Boolean(1);\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。")]),e._v(" "),n("p",[e._v("数值\n使用 number 定义数值类型：")]),e._v(" "),n("p",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n编译结果：")]),e._v(" "),n("p",[e._v("var decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。")]),e._v(" "),n("p",[e._v("字符串\n使用 string 定义字符串类型：")]),e._v(" "),n("p",[e._v("let myName: string = 'Tom';\nlet myAge: number = 25;")]),e._v(" "),n("p",[e._v("// 模板字符串\nlet sentence: string = "),n("code",[e._v("Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.")]),e._v(";\n编译结果：")]),e._v(" "),n("p",[e._v('var myName = \'Tom\';\nvar myAge = 25;\n// 模板字符串\nvar sentence = "Hello, my name is " + myName + ".\\nI\'ll be " + (myAge + 1) + " years old next month.";\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。')]),e._v(" "),n("p",[e._v("空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：")]),e._v(" "),n("p",[e._v("function alertName(): void {\nalert('My name is Tom');\n}\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：")]),e._v(" "),n("p",[e._v("let unusable: void = undefined;\nNull 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：")]),e._v(" "),n("p",[e._v("let u: undefined = undefined;\nlet n: null = null;\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n而 void 类型的变量不能赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("let u: void;\nlet num: number = u;")]),e._v(" "),n("p",[e._v("// Type 'void' is not assignable to type 'number'.原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。")]),e._v(" "),n("p",[e._v("原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。")]),e._v(" "),n("p",[e._v("本节主要介绍前五种原始数据类型在 TypeScript 中的应用。")]),e._v(" "),n("p",[e._v("布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：")]),e._v(" "),n("p",[e._v("let isDone: boolean = false;")]),e._v(" "),n("p",[e._v("// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n注意，使用构造函数 Boolean 创造的对象不是布尔值：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: boolean = new Boolean(1);")]),e._v(" "),n("p",[e._v("// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n事实上 new Boolean() 返回的是一个 Boolean 对象：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: Boolean = new Boolean(1);\n直接调用 Boolean 也可以返回一个 boolean 类型：")]),e._v(" "),n("p",[e._v("let createdByBoolean: boolean = Boolean(1);\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。")]),e._v(" "),n("p",[e._v("数值\n使用 number 定义数值类型：")]),e._v(" "),n("p",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n编译结果：")]),e._v(" "),n("p",[e._v("var decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。")]),e._v(" "),n("p",[e._v("字符串\n使用 string 定义字符串类型：")]),e._v(" "),n("p",[e._v("let myName: string = 'Tom';\nlet myAge: number = 25;")]),e._v(" "),n("p",[e._v("// 模板字符串\nlet sentence: string = "),n("code",[e._v("Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.")]),e._v(";\n编译结果：")]),e._v(" "),n("p",[e._v('var myName = \'Tom\';\nvar myAge = 25;\n// 模板字符串\nvar sentence = "Hello, my name is " + myName + ".\\nI\'ll be " + (myAge + 1) + " years old next month.";\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。')]),e._v(" "),n("p",[e._v("空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：")]),e._v(" "),n("p",[e._v("function alertName(): void {\nalert('My name is Tom');\n}\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：")]),e._v(" "),n("p",[e._v("let unusable: void = undefined;\nNull 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：")]),e._v(" "),n("p",[e._v("let u: undefined = undefined;\nlet n: null = null;\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n而 void 类型的变量不能赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("let u: void;\nlet num: number = u;")]),e._v(" "),n("p",[e._v("// Type 'void' is not assignable to type 'number'.原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。")]),e._v(" "),n("p",[e._v("原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。")]),e._v(" "),n("p",[e._v("本节主要介绍前五种原始数据类型在 TypeScript 中的应用。")]),e._v(" "),n("p",[e._v("布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：")]),e._v(" "),n("p",[e._v("let isDone: boolean = false;")]),e._v(" "),n("p",[e._v("// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n注意，使用构造函数 Boolean 创造的对象不是布尔值：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: boolean = new Boolean(1);")]),e._v(" "),n("p",[e._v("// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n事实上 new Boolean() 返回的是一个 Boolean 对象：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: Boolean = new Boolean(1);\n直接调用 Boolean 也可以返回一个 boolean 类型：")]),e._v(" "),n("p",[e._v("let createdByBoolean: boolean = Boolean(1);\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。")]),e._v(" "),n("p",[e._v("数值\n使用 number 定义数值类型：")]),e._v(" "),n("p",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n编译结果：")]),e._v(" "),n("p",[e._v("var decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。")]),e._v(" "),n("p",[e._v("字符串\n使用 string 定义字符串类型：")]),e._v(" "),n("p",[e._v("let myName: string = 'Tom';\nlet myAge: number = 25;")]),e._v(" "),n("p",[e._v("// 模板字符串\nlet sentence: string = "),n("code",[e._v("Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.")]),e._v(";\n编译结果：")]),e._v(" "),n("p",[e._v('var myName = \'Tom\';\nvar myAge = 25;\n// 模板字符串\nvar sentence = "Hello, my name is " + myName + ".\\nI\'ll be " + (myAge + 1) + " years old next month.";\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。')]),e._v(" "),n("p",[e._v("空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：")]),e._v(" "),n("p",[e._v("function alertName(): void {\nalert('My name is Tom');\n}\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：")]),e._v(" "),n("p",[e._v("let unusable: void = undefined;\nNull 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：")]),e._v(" "),n("p",[e._v("let u: undefined = undefined;\nlet n: null = null;\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n而 void 类型的变量不能赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("let u: void;\nlet num: number = u;")]),e._v(" "),n("p",[e._v("// Type 'void' is not assignable to type 'number'.原始数据类型\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。")]),e._v(" "),n("p",[e._v("原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。")]),e._v(" "),n("p",[e._v("本节主要介绍前五种原始数据类型在 TypeScript 中的应用。")]),e._v(" "),n("p",[e._v("布尔值\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：")]),e._v(" "),n("p",[e._v("let isDone: boolean = false;")]),e._v(" "),n("p",[e._v("// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n注意，使用构造函数 Boolean 创造的对象不是布尔值：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: boolean = new Boolean(1);")]),e._v(" "),n("p",[e._v("// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n事实上 new Boolean() 返回的是一个 Boolean 对象：")]),e._v(" "),n("p",[e._v("let createdByNewBoolean: Boolean = new Boolean(1);\n直接调用 Boolean 也可以返回一个 boolean 类型：")]),e._v(" "),n("p",[e._v("let createdByBoolean: boolean = Boolean(1);\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。")]),e._v(" "),n("p",[e._v("数值\n使用 number 定义数值类型：")]),e._v(" "),n("p",[e._v("let decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n编译结果：")]),e._v(" "),n("p",[e._v("var decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。")]),e._v(" "),n("p",[e._v("字符串\n使用 string 定义字符串类型：")]),e._v(" "),n("p",[e._v("let myName: string = 'Tom';\nlet myAge: number = 25;")]),e._v(" "),n("p",[e._v("// 模板字符串\nlet sentence: string = "),n("code",[e._v("Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.")]),e._v(";\n编译结果：")]),e._v(" "),n("p",[e._v('var myName = \'Tom\';\nvar myAge = 25;\n// 模板字符串\nvar sentence = "Hello, my name is " + myName + ".\\nI\'ll be " + (myAge + 1) + " years old next month.";\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。')]),e._v(" "),n("p",[e._v("空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：")]),e._v(" "),n("p",[e._v("function alertName(): void {\nalert('My name is Tom');\n}\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：")]),e._v(" "),n("p",[e._v("let unusable: void = undefined;\nNull 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：")]),e._v(" "),n("p",[e._v("let u: undefined = undefined;\nlet n: null = null;\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n而 void 类型的变量不能赋值给 number 类型的变量：")]),e._v(" "),n("p",[e._v("let u: void;\nlet num: number = u;")]),e._v(" "),n("p",[e._v("// Type 'void' is not assignable to type 'number'.\n3. 盒子模型，以及标准情况和IE下的区别\n4. 如何实现高度自适应\n5. 动画的了解\n6. 清除浮动\n7. 定位问题（绝对定位、相对定位等）\n8. transform动画和直接使用left、top改变位置有什么优缺点\n9. div垂直水平居中（flex、绝对定位）\n10. 其他css方式设置垂直居中\n11. 居中为什么要使用transform（为什么不使用marginLeft/Top）\n12. 两个元素块，一左一右，中间相距10像素\n13. 介绍flex布局\n14. rem、flex的区别（root em）\n15. em和px的区别\n16. 上下固定，中间滚动布局如何实现\n17. 移动端适配1px的问题\n18. 如何实现H5手机端的适配\n19. 介绍position属性包括CSS3新增\n20. 介绍css3中position:sticky")]),e._v(" "),n("h2",{attrs:{id:"js相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js相关"}},[e._v("#")]),e._v(" js相关")]),e._v(" "),n("h3",{attrs:{id:"异步相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异步相关"}},[e._v("#")]),e._v(" 异步相关")]),e._v(" "),n("ol",[n("li",[e._v("介绍各种异步方案，JS怎么实现异步")]),e._v(" "),n("li",[e._v("JS异步解决方案的发展历程以及优缺点")]),e._v(" "),n("li",[e._v("介绍promise及内部实现")]),e._v(" "),n("li",[e._v("介绍下Promise的用途和性质")]),e._v(" "),n("li",[e._v("Promise有几个状态，Promise的三种状态")]),e._v(" "),n("li",[e._v("介绍Promise的特性，优缺点,promise的精髓，以及优缺点")]),e._v(" "),n("li",[e._v("介绍Promise，异常捕获")]),e._v(" "),n("li",[e._v("介绍Promise和then")]),e._v(" "),n("li",[e._v("promise如何实现then处理")]),e._v(" "),n("li",[e._v("a，b两个按钮，点击aba，返回顺序可能是baa，如何保证是aba（Promise.then）")]),e._v(" "),n("li",[e._v("Promise有没有解决异步的问题（promise链是真正强大的地方）")]),e._v(" "),n("li",[e._v("Promise和Callback有什么区别")]),e._v(" "),n("li",[e._v("如何设计Promise.all()")]),e._v(" "),n("li",[e._v("Promise.all实现原理")]),e._v(" "),n("li",[e._v("promise async await 等异步的实现")]),e._v(" "),n("li",[e._v("使用Async会注意哪些东西")]),e._v(" "),n("li",[e._v("Promise和Async处理失败的时候有什么区别")]),e._v(" "),n("li",[e._v("Async里面有多个await请求，可以怎么优化（请求是否有依赖）")]),e._v(" "),n("li",[e._v("Promise 和 async/await 和 callback的区别")]),e._v(" "),n("li",[e._v("Async/Await怎么实现")]),e._v(" "),n("li",[e._v("对async、await的理解，内部原理")]),e._v(" "),n("li",[e._v("异步请求，低版本fetch如何低版本适配")]),e._v(" "),n("li",[e._v("异步整个执行周期")]),e._v(" "),n("li",[e._v("promise里面和then里面执行有什么区别")]),e._v(" "),n("li",[e._v("Promise构造函数是同步还是异步执行，then呢")]),e._v(" "),n("li",[e._v("Promise和setTimeout的区别（Event Loop）")]),e._v(" "),n("li",[e._v("setInterval需要注意的点")]),e._v(" "),n("li",[e._v("定时器为什么是不精确的")]),e._v(" "),n("li",[e._v("setTimeout(1)和setTimeout(2)之间的区别")]),e._v(" "),n("li",[e._v("Promise和setTimeout执行先后的区别")]),e._v(" "),n("li",[e._v("介绍宏任务和微任务，JS为什么要区分微任务和宏任务")])]),e._v(" "),n("h3",{attrs:{id:"跨域相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#跨域相关"}},[e._v("#")]),e._v(" 跨域相关")]),e._v(" "),n("ol",[n("li",[e._v("对跨域的了解")]),e._v(" "),n("li",[e._v("介绍下浏览器跨域")]),e._v(" "),n("li",[e._v("介绍同源策略")]),e._v(" "),n("li",[e._v("怎么去解决跨域问题")]),e._v(" "),n("li",[e._v("跨域怎么解决，有没有使用过Apache等方案")]),e._v(" "),n("li",[e._v("表单可以跨域吗")]),e._v(" "),n("li",[e._v("ajax如何处理跨域")]),e._v(" "),n("li",[e._v("Ajax发生跨域要设置什么（前端）")]),e._v(" "),n("li",[e._v("jsonp方案需要服务端怎么配合")]),e._v(" "),n("li",[e._v("jsonp为什么不支持post方法")]),e._v(" "),n("li",[e._v("CORS如何设置")]),e._v(" "),n("li",[e._v("加上CORS之后从发起到请求正式成功的过程")]),e._v(" "),n("li",[e._v("xsrf跨域攻击的安全性问题怎么防范")])]),e._v(" "),n("h3",{attrs:{id:"其它"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[e._v("#")]),e._v(" 其它")]),e._v(" "),n("ol",[n("li",[e._v("文件上传如何做断点续传")]),e._v(" "),n("li",[e._v("搜索请求如何处理（防抖）")]),e._v(" "),n("li",[e._v("搜索请求中文如何请求")]),e._v(" "),n("li",[e._v("介绍事件代理以及优缺点")]),e._v(" "),n("li",[e._v("防抖和节流的区别")]),e._v(" "),n("li",[e._v("get和post有什么区别")]),e._v(" "),n("li",[e._v("介绍下事件代理，主要解决什么问题")]),e._v(" "),n("li",[e._v("服务端怎么做统一的状态处理")]),e._v(" "),n("li",[e._v("浏览器事件流向")])]),e._v(" "),n("h2",{attrs:{id:"数据接口预算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据接口预算法"}},[e._v("#")]),e._v(" 数据接口预算法")]),e._v(" "),n("h3",{attrs:{id:"数据结构相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构相关"}},[e._v("#")]),e._v(" 数据结构相关")]),e._v(" "),n("ol",[n("li",[e._v("项目中如何应用数据结构")]),e._v(" "),n("li",[e._v("项目中树的使用场景以及了解")]),e._v(" "),n("li",[e._v("如何判断链表是否有环")]),e._v(" "),n("li",[e._v("介绍二叉搜索树的特点")]),e._v(" "),n("li",[e._v("如何设计状态树")])]),e._v(" "),n("h2",{attrs:{id:"node相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#node相关"}},[e._v("#")]),e._v(" node相关")]),e._v(" "),n("ol",[n("li",[e._v("介绍koa2")]),e._v(" "),n("li",[e._v("koa-body原理")]),e._v(" "),n("li",[e._v("使用的koa中间件")]),e._v(" "),n("li",[e._v("常用的中间件")]),e._v(" "),n("li",[e._v("使用过的koa2中间件")]),e._v(" "),n("li",[e._v("koa2中间件原理")]),e._v(" "),n("li",[e._v("介绍自己写过的中间件")]),e._v(" "),n("li",[e._v("有没有涉及到Cluster")]),e._v(" "),n("li",[e._v("koa原理，为什么要用koa(express和koa对比")]),e._v(" "),n("li",[e._v("介绍pm2")]),e._v(" "),n("li",[e._v("master挂了的话pm2怎么处理")]),e._v(" "),n("li",[e._v("如何和MySQL进行通信")]),e._v(" "),n("li",[e._v("koa中response.send、response.rounded、response.json发生了什么事，浏览器为什么能识别到它是一个json结构或是html")]),e._v(" "),n("li",[e._v("koa-bodyparser怎么来解析request")]),e._v(" "),n("li",[e._v("knex连接数据库响应回调")]),e._v(" "),n("li",[e._v("node接口转发有无做什么优化")]),e._v(" "),n("li",[e._v("node起服务如何保证稳定性，平缓降级，重启等")]),e._v(" "),n("li",[e._v("node文件查找优先级")]),e._v(" "),n("li",[e._v("进程和线程的区别（一个node实例就是一个进程，node是单线程，通过事件循环来实现异步）")])]),e._v(" "),n("h2",{attrs:{id:"http相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http相关"}},[e._v("#")]),e._v(" http相关")]),e._v(" "),n("ol",[n("li",[e._v("介绍HTTPS")]),e._v(" "),n("li",[e._v("介绍http2.0")]),e._v(" "),n("li",[e._v("HTTP和HTTPS的区别")]),e._v(" "),n("li",[e._v("HTTPS怎么建立安全通道")]),e._v(" "),n("li",[e._v("HTTPS的加密过程")]),e._v(" "),n("li",[e._v("介绍SSL和TLS")]),e._v(" "),n("li",[e._v("介绍service worker")]),e._v(" "),n("li",[e._v("介绍DNS解析")]),e._v(" "),n("li",[e._v("网络的五层模型")]),e._v(" "),n("li",[e._v("http1.1时如何复用tcp连接")]),e._v(" "),n("li",[e._v("tcp3次握手")]),e._v(" "),n("li",[e._v("tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）")]),e._v(" "),n("li",[e._v("从输入URL到页面加载全过程")]),e._v(" "),n("li",[e._v("http缓存控制")]),e._v(" "),n("li",[e._v("缓存相关的HTTP请求头")]),e._v(" "),n("li",[e._v("介绍下HTTP状态码")]),e._v(" "),n("li",[e._v("403、301、302、304是什么")]),e._v(" "),n("li",[e._v("Http报文的请求会有几个部分")]),e._v(" "),n("li",[e._v("常见Http请求头")]),e._v(" "),n("li",[e._v("通过什么做到并发请求")]),e._v(" "),n("li",[e._v("Access-Control-Allow-Origin在服务端哪里配置")]),e._v(" "),n("li",[e._v("服务端渲染SSR")]),e._v(" "),n("li",[e._v("csrf跨站攻击怎么解决")])]),e._v(" "),n("h2",{attrs:{id:"react相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react相关"}},[e._v("#")]),e._v(" react相关")]),e._v(" "),n("ol",[n("li",[e._v("React声明周期及自己的理解")]),e._v(" "),n("li",[e._v("如何配置React-Router")]),e._v(" "),n("li",[e._v("路由的动态加载模块")]),e._v(" "),n("li",[e._v("介绍Redux数据流的流程")]),e._v(" "),n("li",[e._v("Redux如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理")]),e._v(" "),n("li",[e._v("使用过的Redux中间件")]),e._v(" "),n("li",[e._v("介绍redux，主要解决什么问题")]),e._v(" "),n("li",[e._v("介绍react优化")]),e._v(" "),n("li",[e._v("React组件中怎么做事件代理")]),e._v(" "),n("li",[e._v("React组件事件代理的原理")]),e._v(" "),n("li",[e._v("React怎么做数据的检查和变化")]),e._v(" "),n("li",[e._v("redux请求中间件如何处理并发")]),e._v(" "),n("li",[e._v("react-router怎么实现路由切换")]),e._v(" "),n("li",[e._v("react-router里的标签和标签有什么区别")]),e._v(" "),n("li",[e._v("React层面的性能优化")]),e._v(" "),n("li",[e._v("Redux中异步的请求怎么处理")]),e._v(" "),n("li",[e._v("Redux中间件是什么东西，接受几个参数（两端的柯里化函数）")]),e._v(" "),n("li",[e._v("state是怎么注入到组件的，从reducer到组件经历了什么样的过程")]),e._v(" "),n("li",[e._v("如何做RN在安卓和IOS端的适配")]),e._v(" "),n("li",[e._v("RN为什么能在原生中绘制成原生组件（bundle.js）")]),e._v(" "),n("li",[e._v("Redux在状态管理方面解决了React本身不能解决的问题")]),e._v(" "),n("li",[e._v("Redux有没有做过封装")]),e._v(" "),n("li",[e._v("react生命周期，常用的生命周期")]),e._v(" "),n("li",[e._v("写react有哪些细节可以优化")]),e._v(" "),n("li",[e._v("React的事件机制（绑定一个事件到一个组件上）")]),e._v(" "),n("li",[e._v("React/Redux中哪些功能用到了哪些设计模式")]),e._v(" "),n("li",[e._v("React子父组件之间如何传值")]),e._v(" "),n("li",[e._v("介绍下React高阶组件，和普通组件有什么区别")]),e._v(" "),n("li",[e._v("一个对象数组，每个子对象包含一个id和name，React如何渲染出全部的name")]),e._v(" "),n("li",[e._v("在哪个生命周期里写")]),e._v(" "),n("li",[e._v("其中有几个name不存在，通过异步接口获取，如何做")]),e._v(" "),n("li",[e._v("介绍Fiber")]),e._v(" "),n("li",[e._v("shouldComponentUpdate是为了解决什么问题")]),e._v(" "),n("li",[e._v("react中的key的作用")]),e._v(" "),n("li",[e._v("native提供了什么能力给RN")]),e._v(" "),n("li",[e._v("React中Dom结构发生变化后内部经历了哪些变化")]),e._v(" "),n("li",[e._v("React挂载的时候有3个组件，textComponent、composeComponent、domComponent，区别和关系，Dom结构发生变化时怎么区分data的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理")]),e._v(" "),n("li",[e._v("redux的设计思想")]),e._v(" "),n("li",[e._v("接入redux的过程")]),e._v(" "),n("li",[e._v("react异步渲染的概念,介绍Time Slicing 和 Suspense")]),e._v(" "),n("li",[e._v("react性能优化")]),e._v(" "),n("li",[e._v("react生命周期")]),e._v(" "),n("li",[e._v("React使用过的一些组件")]),e._v(" "),n("li",[e._v("介绍Immuable")]),e._v(" "),n("li",[e._v("介绍下redux整个流程原理")]),e._v(" "),n("li",[e._v("React声明周期")]),e._v(" "),n("li",[e._v("Redux状态管理器和变量挂载到window中有什么区别")]),e._v(" "),n("li",[e._v("React数据流")]),e._v(" "),n("li",[e._v("对React看法，有没有遇到一些坑")]),e._v(" "),n("li",[e._v("react设计思路")]),e._v(" "),n("li",[e._v("redux状态树的管理")]),e._v(" "),n("li",[e._v("react常见的通信方式")]),e._v(" "),n("li",[e._v("redux整体的工作流程")]),e._v(" "),n("li",[e._v("redux和全局对象之间的区别")]),e._v(" "),n("li",[e._v("Redux数据回溯设计思路")]),e._v(" "),n("li",[e._v("react性能优化")]),e._v(" "),n("li",[e._v("介绍pureComponet")]),e._v(" "),n("li",[e._v("props和state的区别")]),e._v(" "),n("li",[e._v("介绍react context")]),e._v(" "),n("li",[e._v("React15/16.x的区别")]),e._v(" "),n("li",[e._v("重新渲染render会做些什么")]),e._v(" "),n("li",[e._v("哪些方法会触发react重新渲染")]),e._v(" "),n("li",[e._v("state和props触发更新的生命周期分别有什么区别")]),e._v(" "),n("li",[e._v("setState是同步还是异步")]),e._v(" "),n("li",[e._v("对无状态组件的理解")]),e._v(" "),n("li",[e._v("介绍Redux工作流程")]),e._v(" "),n("li",[e._v("对react看法，它的优缺点")]),e._v(" "),n("li",[e._v("使用过程中遇到的问题，如何解决的")]),e._v(" "),n("li",[e._v("react的理念是什么（拿函数式编程来做页面渲染）")]),e._v(" "),n("li",[e._v("介绍redux接入流程")]),e._v(" "),n("li",[e._v("rudux和全局管理有什么区别（数据可控、数据响应）")]),e._v(" "),n("li",[e._v("RN和原生通信")]),e._v(" "),n("li",[e._v("RN有没有做热加载")]),e._v(" "),n("li",[e._v("RN遇到的兼容性问题")]),e._v(" "),n("li",[e._v("RN如何实现一个原生的组件")]),e._v(" "),n("li",[e._v("RN混原生和原生混RN有什么不同")]),e._v(" "),n("li",[e._v("RN的原理，为什么可以同时在安卓和IOS端运行")]),e._v(" "),n("li",[e._v("RN如何调用原生的一些功能")]),e._v(" "),n("li",[e._v("介绍RN的缺点")]),e._v(" "),n("li",[e._v("React中setState后发生了什么")]),e._v(" "),n("li",[e._v("setState为什么默认是异步")]),e._v(" "),n("li",[e._v("setState什么时候是同步的")]),e._v(" "),n("li",[e._v("React的生命周期")]),e._v(" "),n("li",[e._v("componentWillReceiveProps的触发条件是什么")]),e._v(" "),n("li",[e._v("React16.3对生命周期的改变")]),e._v(" "),n("li",[e._v("介绍下React的Filber架构")]),e._v(" "),n("li",[e._v("画Filber渲染树")]),e._v(" "),n("li",[e._v("介绍React高阶组件")]),e._v(" "),n("li",[e._v("父子组件之间如何通信")]),e._v(" "),n("li",[e._v("Redux怎么实现属性传递，介绍下原理")]),e._v(" "),n("li",[e._v("React-Router版本号")]),e._v(" "),n("li",[e._v("pureComponent和FunctionComponent区别")])]),e._v(" "),n("h2",{attrs:{id:"webpack打包优化相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包优化相关"}},[e._v("#")]),e._v(" webpack打包优化相关")]),e._v(" "),n("ol",[n("li",[e._v("webpack介绍")]),e._v(" "),n("li",[e._v("webpack做了什么")]),e._v(" "),n("li",[e._v("webpack生命周期")]),e._v(" "),n("li",[e._v("webpack和gulp的优缺点")]),e._v(" "),n("li",[e._v("webpack打包的整个过程")]),e._v(" "),n("li",[e._v("import { Button } from 'antd'，打包的时候只打包button，分模块加载，是怎么做到的")]),e._v(" "),n("li",[e._v("使用import时，webpack对node_modules里的依赖会做什么")]),e._v(" "),n("li",[e._v("webpack整个生命周期，loader和plugin有什么区别")]),e._v(" "),n("li",[e._v("如何实现分模块打包（多入口）")]),e._v(" "),n("li",[e._v("webpack如何配sass，需要配哪些loader")]),e._v(" "),n("li",[e._v("配css需要哪些loader")]),e._v(" "),n("li",[e._v("一般怎么组织CSS（Webpack）")]),e._v(" "),n("li",[e._v("常用的plugins")]),e._v(" "),n("li",[e._v("使用过webpack里面哪些plugin和loader")]),e._v(" "),n("li",[e._v("如何配置把js、css、html单独打包成一个文件")]),e._v(" "),n("li",[e._v("使用webpack构建时有无做一些自定义操作")]),e._v(" "),n("li",[e._v("pm2怎么做进程管理，进程挂掉怎么处理")]),e._v(" "),n("li",[e._v("不用pm2怎么做进程管理")]),e._v(" "),n("li",[e._v("webpack里面的插件是怎么实现的")]),e._v(" "),n("li",[e._v("dev-server是怎么跑起来")]),e._v(" "),n("li",[e._v("打包时Hash码是怎么生成的")])]),e._v(" "),n("h2",{attrs:{id:"项目优化项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目优化项目"}},[e._v("#")]),e._v(" 项目优化项目")]),e._v(" "),n("ol",[n("li",[e._v("抽取公共文件是怎么配置的")]),e._v(" "),n("li",[e._v("前端项目优化（1js css；2 图片；3 缓存预加载； 4 SSR； 5 多域名加载；6 负载均衡）")]),e._v(" "),n("li",[e._v("前端性能优化（JS原生和React）")]),e._v(" "),n("li",[e._v("用户体验做过什么优化")]),e._v(" "),n("li",[e._v("网站SEO怎么处理")]),e._v(" "),n("li",[e._v("如何做工程上的优化")]),e._v(" "),n("li",[e._v("整个前端性能提升大致分几类")]),e._v(" "),n("li",[e._v("遇到性能问题一般在哪个生命周期里解决")]),e._v(" "),n("li",[e._v("怎么做性能优化（异步加载组件...）")]),e._v(" "),n("li",[e._v("并发请求资源数上限（6个）")]),e._v(" "),n("li",[e._v("base64为什么能提升性能，缺点")]),e._v(" "),n("li",[e._v("介绍webp这个图片文件格式")])]),e._v(" "),n("h2",{attrs:{id:"模式及排序相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模式及排序相关"}},[e._v("#")]),e._v(" 模式及排序相关")]),e._v(" "),n("ol",[n("li",[e._v("介绍观察者模式")]),e._v(" "),n("li",[e._v("介绍中介者模式")]),e._v(" "),n("li",[e._v("观察者和订阅-发布的区别，各自用在哪里")]),e._v(" "),n("li",[e._v("观察者模式里面使用的数据结构(不具备顺序 ，是一个list)")]),e._v(" "),n("li",[e._v("介绍排序算法和快排原理")]),e._v(" "),n("li",[e._v("介绍冒泡排序，选择排序，冒泡排序如何优化")]),e._v(" "),n("li",[e._v("介绍快速排序")]),e._v(" "),n("li",[e._v("JS是什么范式语言(面向对象还是函数式编程)")]),e._v(" "),n("li",[e._v("介绍下DFS深度优先")]),e._v(" "),n("li",[e._v("介绍纯函数")])]),e._v(" "),n("h2",{attrs:{id:"其它未分类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其它未分类"}},[e._v("#")]),e._v(" 其它未分类")]),e._v(" "),n("ol",[n("li",[e._v("介绍垃圾回收")]),e._v(" "),n("li",[e._v("JS里垃圾回收机制是什么，常用的是哪种，怎么处理的")]),e._v(" "),n("li",[e._v("添加原生事件不移除为什么会内存泄露")]),e._v(" "),n("li",[e._v("还有哪些地方会内存泄露")]),e._v(" "),n("li",[e._v("如何对相对路径引用进行优化")]),e._v(" "),n("li",[e._v("介绍路由的history")]),e._v(" "),n("li",[e._v("前端怎么控制管理路由")]),e._v(" "),n("li",[e._v("使用路由时出现问题如何解决")]),e._v(" "),n("li",[e._v("多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块")]),e._v(" "),n("li",[e._v("项目中如何处理安全问题")]),e._v(" "),n("li",[e._v("算法：前K个最大的元素")]),e._v(" "),n("li",[e._v("柯里化函数两端的参数具体是什么东西")]),e._v(" "),n("li",[e._v("介绍AST（Abstract Syntax Tree）抽象语法树")]),e._v(" "),n("li",[e._v("安卓Activity之间数据是怎么传递的")]),e._v(" "),n("li",[e._v("安卓4.0到6.0过程中WebView对js兼容性的变化")]),e._v(" "),n("li",[e._v("WebView和原生是如何通信")]),e._v(" "),n("li",[e._v("中间件是怎么拿到store和action，然后怎么处理")]),e._v(" "),n("li",[e._v("key主要是解决哪一类的问题，为什么不建议用索引index（重绘）")]),e._v(" "),n("li",[e._v("介绍defineProperty方法，什么时候需要用到")]),e._v(" "),n("li",[e._v("介绍高阶组件")]),e._v(" "),n("li",[e._v("sum(2, 3)实现sum(2)(3)的效果")]),e._v(" "),n("li",[e._v("遇到的复杂业务场景")]),e._v(" "),n("li",[e._v("工作收获")]),e._v(" "),n("li",[e._v("介绍css，xsrf")]),e._v(" "),n("li",[e._v("介绍Function Component")]),e._v(" "),n("li",[e._v("如何处理异常捕获")]),e._v(" "),n("li",[e._v("项目如何管理模块")]),e._v(" "),n("li",[e._v("如何判断是button")]),e._v(" "),n("li",[e._v("页面上有1万个button如何绑定事件")]),e._v(" "),n("li",[e._v("页面上生成一万个button，并且绑定事件，如何做（JS原生操作DOM）")]),e._v(" "),n("li",[e._v("数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少")]),e._v(" "),n("li",[e._v("对应的生命周期做什么事")]),e._v(" "),n("li",[e._v("小程序里面开页面最多多少")]),e._v(" "),n("li",[e._v("Emit事件怎么发，需要引入什么")]),e._v(" "),n("li",[e._v("如何解决props层级过深的问题")]),e._v(" "),n("li",[e._v("前端怎么做单元测试")]),e._v(" "),n("li",[e._v("介绍JSX")]),e._v(" "),n("li",[e._v("为什么3大框架出现以后就出现很多native（RN）框架（虚拟DOM）")]),e._v(" "),n("li",[e._v("介绍MVP怎么组织")]),e._v(" "),n("li",[e._v("npm2和npm3+有什么区别")]),e._v(" "),n("li",[e._v("对PWA有什么了解")]),e._v(" "),n("li",[e._v("对安全有什么了解")]),e._v(" "),n("li",[e._v("RESTful常用的Method")]),e._v(" "),n("li",[e._v("绑定connect的过程")]),e._v(" "),n("li",[e._v("connect原理")]),e._v(" "),n("li",[e._v("16.X声明周期的改变")]),e._v(" "),n("li",[e._v("16.X中props改变后在哪个生命周期中处理")])])])}),[],!1,null,null,null);v.default=l.exports}}]);